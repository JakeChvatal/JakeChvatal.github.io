<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Jacob Chvatal 2</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}

			#menu {
				position: absolute;
				bottom: 20px;
				width: 100%;
				text-align: center;
			}
		</style>
	</head>
	<body>

		<script src="./build/three.js"></script>

		<script src="./modules/Projector.js"></script>
		<script src="./modules/CanvasRenderer.js"></script>
		<script src = "./modules/CSS3DRenderer.js"></script>

		<script src="./modules/stats.min.js"></script>
		<script src="./modules/tween.min.js"></script>

		<script>
			var container, stats;
			var camera, scene, renderer;
			var rendererCSS;
			
			var raycaster;
			var mouse;
			var objects = [];
			var targets = {grid: [], align: [] };

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 2000;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf0f0f0 );

				var geometry = new THREE.BoxGeometry( 20, 20, 20 );

				
				for ( var i = 0; i < 10; i ++ ) {

					var object = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, opacity: 0.5 } ) );
					object.position.x = Math.random() * 800 - 400;
					object.position.y = Math.random() * 800 - 400;
					object.position.z = Math.random() * 800 - 400;
					object.scale.x = Math.random() * 2 + 1;
					object.scale.y = Math.random() * 2 + 1;
					object.scale.z = Math.random() * 2 + 1;
					object.rotation.x = Math.random() * 2 * Math.PI;
					object.rotation.y = Math.random() * 2 * Math.PI;
					object.rotation.z = Math.random() * 2 * Math.PI;
					scene.add( object );
					objects.push(object);
				}

				//grid
				for ( var i = 0; i < objects.length; i ++ ) {
					var object = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, opacity: 0.5 } ) );
					object.position.x = window.innerWidth / (objects.length) * (i % 5) - window.innerWidth/5;
					object.position.y = Math.floor(i / 5) * window.innerHeight/5;
					object.position.z = 1000;
					targets.grid.push( object );
				}

				//align
				for(var i = 0; i< objects.length; i++){
					var object = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, opacity: 0.5 } ) );
					object.position.x = -window.innerWidth/2;
					object.position.y = - i * window.innerHeight / (objects.length) + window.innerHeight/2;// - window.innerHeight/(objects.length - 1);
					object.position.z = -100;
					targets.align.push( object );
				}
				
				//
				
				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();

				renderer = new THREE.CanvasRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild(renderer.domElement);

				// create a new scene to hold CSS
				cssScene = new THREE.Scene();

				// create a renderer for CSS
				rendererCSS	= new THREE.CSS3DRenderer();
				rendererCSS.setSize( window.innerWidth, window.innerHeight );
				rendererCSS.domElement.style.position = 'absolute';
				rendererCSS.domElement.style.top	  = 0;
				rendererCSS.domElement.style.margin	  = 0;
				rendererCSS.domElement.style.padding  = 0;
				container.appendChild( rendererCSS.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );
				
				transform(targets.grid, 1000);
				//
				document.addEventListener( 'mousedown', onMouseDown, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function transform( targets, duration, intersectObject) {

				TWEEN.removeAll();

				for ( var i = 0; i < objects.length; i ++ ) {

					var object = objects[ i ];
					var target = targets[ i ];
					
					var zOffset = 0;

					if(target == intersectObject){
						zOffset = 1000;
					}

					new TWEEN.Tween( object.position )
						.to( { x: target.position.x, y: target.position.y, z: target.position.z + zOffset }, Math.random() * duration + duration )
						.easing( TWEEN.Easing.Exponential.InOut )
						.start();

					new TWEEN.Tween( object.rotation )
						.to( { x: target.rotation.x, y: target.rotation.y, z: target.rotation.z }, Math.random() * duration + duration )
						.easing( TWEEN.Easing.Exponential.InOut )
						.start();
					
				}

				new TWEEN.Tween( this )
					.to( {}, duration * 2 )
					.onUpdate( render )
					.start();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}
			
			function onDocumentTouchStart( event ) {
				
				event.preventDefault();
				
				event.clientX = event.touches[0].clientX;
				event.clientY = event.touches[0].clientY;
				onDocumentMouseDown( event );

			}	

			function onMouseDown( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( scene.children );

				if ( intersects.length > 0 ) {
					transform(targets.align, 1000, intersects[0]);
					getDetailsPage("objInfo");

				}else{
					transform(targets.grid, 1000);
					clearCSSScene();
				}
			}

			function onMouseMove(){
				event.preventDefault();

				
				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( scene.children );

				if(intersects.length > 0){
					transform(targets.grid, 500, intersects[0]);
				}
				
			}

			function getDetailsPage(detail){
				var element	= document.createElement('iframe')
				element.src	= `./infoPages/${detail}.html`; //eventually insert key for each site here, create page for each 

				// width of iframe in pixels
				var elementWidth = 1024;
				// force iframe to have same relative dimensions as planeGeometry
				var aspectRatio = 1;
				var elementHeight = elementWidth * aspectRatio;
				element.style.width  = elementWidth + "px";
				element.style.height = elementHeight + "px";
				
				// create a CSS3DObject to display element
				var cssObject = new THREE.CSS3DObject( element );
				cssScene.add(cssObject);
			}

			function clearCSSScene(){
				cssScene.children.forEach((child) =>{
					cssScene.remove(child);
				});
			}
			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				TWEEN.update();
				stats.update();
			}

			function render() {
				camera.lookAt( scene.position );

				rendererCSS.render(cssScene, camera);
				renderer.render( scene, camera );
			}
		</script>

	</body>
</html>
